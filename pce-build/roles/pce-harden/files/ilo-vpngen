#!/usr/bin/env bash
#
# Copyright 2019 Illumio, Inc. All Rights Reserved.
#

read -r -d '' USAGE <<EOF
Usage: $0 -i <input file> -o <output file>

The input file contains a list of IP addresses, one per line. Blank
lines and lines starting with '#' are ignored, and any text following
the IP address is also ignored.

This input file should contain the private IP addresses of all nodes in
your cluster. The private IP addresses are the addresses that the PCE
nodes use to communicate with each other. Public IP addresses of PCE nodes
should not be included. For supercluster installations, don't include
IP addresses of nodes in peer clusters.

The output file will contain a script that should be run on each node
in the PCE cluster to check that the node has the proper packages installed
and deploy the IPsec VPN configuration.
EOF

fail() {
  echo "FAIL" 1>&2
  echo "$1" 1>&2
  exit 1
}

usage() {
  echo "$1" 1>&2
  echo "Run $0 -h for help." 1>&2
  exit 1
}

while getopts "i:o:h" OPTION; do
  case "$OPTION" in
    i) INPUT="$OPTARG" ;;
    o) OUTPUT="$OPTARG" ;;
    h) fail "$USAGE" ;;
    *) usage "Invalid argument." ;;
  esac
done

[[ "$INPUT"  == "" ]] && usage "No input file specified."
[[ "$OUTPUT" == "" ]] && usage "No output file specified."

exec 0<"$INPUT" || fail "Error reading $INPUT"

#############################################################
# Read Input IP Addresses, creating all IP-pairs as we go
#############################################################
declare -a IP_ADDRS
declare -a ADDR_PAIRS

while read LINE; do
  if [[ ! "$LINE" =~ ^([0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}) ]]; then
    if [[ "$LINE" != "" ]] && [[ ! "$LINE" =~ ^# ]]; then
      echo "WARNING: line ignored due to no valid IP address found: [$LINE]" 1>&2
    fi
    continue
  fi
  NEW_IP=${BASH_REMATCH[1]}
  [[ " ${IP_ADDRS[@]} " =~ " ${NEW_IP} " ]] && fail "Duplicate IP address found: ${NEW_IP}"

  for IP in ${IP_ADDRS[*]}; do
    ADDR_PAIRS+=(${NEW_IP}_${IP})
  done
  IP_ADDRS+=($NEW_IP)
done

n=${#IP_ADDRS[@]}
[[ ${n} -eq 0 ]] && fail "No IP addresses found in input file \"${INPUT}\""
if [[ ${n} -ne 4 ]] && [[ ${n} -ne 6 ]]; then
  echo ; echo "WARNING: found ${n} IP addresses." 1>&2
  echo "Expected 4 or 6 IP addesses (for a 2x2 or 4x2 PCE cluster, respectively)." 1>&2
fi
n=${#ADDR_PAIRS[@]}
if [[ ${n} -ne 6 ]] && [[ ${n} -ne 15 ]]; then
  echo ; echo "WARNING: found ${n} pairs of IP addresses." 1>&2
  echo "Expected 6 or 15 pairs of IP addesses (for a 2x2 or 4x2 PCE cluster, respectively)." 1>&2
fi

#############################################################
# Generate Secrets and Conf file text as string variables
#############################################################

NL=$'\n'
NOW="$(date)"
HEADER="# Generated by $0 on ${HOSTNAME}${NL}"
HEADER+="# ${NOW}${NL}"
HEADER+="#${NL}"

SECRETS_TXT=$HEADER
CONF_TXT=$HEADER

PSK_CMD="openssl rand -base64 48"

for PAIR in ${ADDR_PAIRS[*]}; do
  PSK=$(${PSK_CMD})
  len=${#PSK}
  [[ $len != 64 ]] && fail "Problem generating PSK with ${PSK_CMD}"

  IFS='_' read -r -a ADDRS <<< "${PAIR}"
  LEFT=${ADDRS[0]}
  RIGHT=${ADDRS[1]}
  SECRETS_TXT+="${LEFT} ${RIGHT} : PSK \"${PSK}\"${NL}"

  CONF_TXT+="conn pce_${PAIR}${NL}"
  CONF_TXT+="    ikev2=insist${NL}"
  CONF_TXT+="    left=${LEFT}${NL}"
  CONF_TXT+="    right=${RIGHT}${NL}"
  CONF_TXT+="    authby=secret${NL}"
  CONF_TXT+="    type=transport${NL}"
  # We require AES_GCM because of its ~2x better performance over AES+SHA1.
  # We require AES_GCM with 128-bit keys because some linux kernel aes-ni drivers
  # have a bug with 256-bit keys.  See the "Using aes_gcm or aes_ctr results in ERROR"
  # section of https://libreswan.org/wiki/FAQ.
  CONF_TXT+="    esp=aes_gcm128-null${NL}"
  CONF_TXT+="    auto=start${NL}"
done

#############################################################
# Generate script to check things and put conf files in place.
# Use template below without variable expansion, just the
# replacement of the __SECRETS_TXT__ and __CONF_TXT__ placeholders.
#############################################################

# Preserve leading spaces in template
OLDIFS=$IFS
IFS=''

while read -r line; do
  newline="${line/'__SECRETS_TXT__'/${SECRETS_TXT}}"
  echo "${newline/'__CONF_TXT__'/${CONF_TXT}}"
done > "${OUTPUT}" << 'END_OF_TEMPLATE'
#!/usr/bin/env bash
#
# Copyright 2019 Illumio, Inc. All Rights Reserved.
#

IPSEC_CONF_DIR="/etc/ipsec.d"
SECRETS_FILE="${IPSEC_CONF_DIR}/pce_vpn.secrets"
CONF_FILE="${IPSEC_CONF_DIR}/pce_vpn.conf"
MIN_LIBRESWAN_VER="3.29"

echo_stderr() {
  echo "$1" 1>&2
}

fail() {
  echo_stderr "FAIL"
  echo_stderr "$1"
  exit 1
}

get_cmd() {
  [[ $OS_VER_NUM -eq 7 ]] && { echo "systemctl $1 ipsec"; return; }
  [[ "$1" == "enable" ]] && { echo "chkconfig ipsec on"; return; }
  [[ "$1" == "disable" ]] && { echo "chkconfig ipsec off"; return; }
  echo "service ipsec $1" 
}


# Compare version strings (e.g., "3.28.1").  Return true if first version > second version.
function version_gt() { test "$(printf '%s\n' "$@" | sort -V | head -n 1)" != "$1"; }

# Set command strings, pkg versions based on detected CentOS/RHEL version
#
RH_PKG="$(rpm -qf /etc/redhat-release)"
[[ $? -ne 0 ]] && fail "Unable to determine OS version using rpm"

START="start"
OS_VER_NUM="$(expr match "${RH_PKG}" '[^0-9]*\([0-9]\)')"
case "${OS_VER_NUM}" in
  6)
    REQ_PKGS="libreswan ldns libevent libevent2 unbound-libs"
    MIN_NSS_TOOLS_VER="3.28.4"
    ;;
  7)
    REQ_PKGS="libreswan ldns libevent unbound-libs"
    MIN_NSS_TOOLS_VER=
    ;;
  *)
    fail "Could not find OS version number from pkg name \"${RH_PKG}\""
esac

status="$($(get_cmd status) 2> /dev/null)"
[[ $? -eq 0 ]] && [[ "$status" =~ "running" ]] && START="restart"

# Disable service when -disable arg is given
#
if [ $# -ne 0 ]; then
  [[ "$1" != "-disable" ]] && fail "Unrecognized argument: \"$1\" (only \"-disable\" is supported)"
  echo "Disabling ipsec service..."
  echo "Running \"$(get_cmd disable)\""
  $(get_cmd disable)
  [[ $? -ne 0 ]] && fail "Unable to disable ipsec service"
  echo "SUCCESS"
  echo "Disabled ipsec service. You can remove these ipsec configuration files:"
  echo "  ${CONF_FILE}"
  echo "  ${SECRETS_FILE}"
  exit 0
fi

# Check for required packages
#
declare -a MISSING_PKGS
for pkg in ${REQ_PKGS}; do
  rpm -q ${pkg} > /dev/null
  [[ $? -ne 0 ]] && MISSING_PKGS+=(${pkg})
done
if [[ ${#MISSING_PKGS[@]} -ne 0 ]]; then
  echo_stderr "FAIL"
  echo_stderr "Did not find the following rpm packages installed:"
  for pkg in ${MISSING_PKGS[@]}; do
    echo_stderr "  ${pkg}"
  done
  echo_stderr "Please install these packages and run this script again."
  exit 1
fi

FAILED=0

if [[ -n "${MIN_NSS_TOOLS_VER}" ]]; then
  # Check for incompatible version of nss-tools (CentOS/RHEL 6)
  #
  my_ver="$(rpm -q --qf %{VERSION} nss-tools)"

  if [[ ${my_ver} != ${MIN_NSS_TOOLS_VER} ]] && ! version_gt ${my_ver} ${MIN_NSS_TOOLS_VER}; then
    echo_stderr "FAIL"
    echo_stderr "Incompatible version of nss-tools (${my_ver}) installed."
    echo_stderr "Please install nss-tools with version >= ${MIN_NSS_TOOLS_VER}"
    FAILED=1
  fi
fi

my_ver="$(rpm -q --qf %{VERSION} libreswan)"

# Check that libreswan version is not 3.27* (see https://libreswan.org/security/CVE-2019-12312/CVE-2019-12312.txt)
if [[ ${my_ver} =~ ^3.27 ]]; then
  echo_stderr "FAIL"
  echo_stderr "Installed version of libreswan is ${my_ver} which is not supported."
  echo_stderr "Please update libreswan with version >= ${MIN_LIBRESWAN_VER}"
  FAILED=1
# Check for min version of libreswan (to avoid https://libreswan.org/security/CVE-2019-10155/CVE-2019-10155.txt)
elif [[ ${my_ver} != ${MIN_LIBRESWAN_VER} ]] && ! version_gt ${my_ver} ${MIN_LIBRESWAN_VER}; then
  echo_stderr "WARNING"
  echo_stderr "Installed version of libreswan is ${my_ver}."
  echo_stderr "Suggest updating libreswan with version >= ${MIN_LIBRESWAN_VER}"
fi

# Check for too low value for net.ipv4.xfrm4_gc_thresh
v="$(sysctl -n net.ipv4.xfrm4_gc_thresh)"
if [ $? -ne 0 ]; then
  echo_stderr "FAIL"
  echo_stderr "Unable to check value of net.ipv4.xfrm4_gc_thresh"
  FAILED=1
else
  if [ $v -lt 32768 ]; then
    echo_stderr "FAIL"
    echo_stderr "Must have net.ipv4.xfrm4_gc_thresh >= 32768"
    echo_stderr "Please modify kernel parameter with sysctl and/or sysctl.conf"
    FAILED=1
  fi
fi

[ $FAILED -ne 0 ] && exit 1

# Check for permission to create files in ${IPSEC_CONF_DIR}
#
touch ${CONF_FILE} &> /dev/null
[[ $? -ne 0 ]] && fail "Permission problem. Unable to create file ${CONF_FILE}"

# Write IPsec secrets and config files
#
cat << 'EOF' > "${SECRETS_FILE}"
__SECRETS_TXT__
EOF
echo "Wrote secrets to ${SECRETS_FILE}"
chmod 400 "${SECRETS_FILE}"

cat << 'EOF' > "${CONF_FILE}"
__CONF_TXT__
EOF
echo "Wrote configuration to ${CONF_FILE}"
chmod 444 "${CONF_FILE}"

# Enable IPsec service
#
echo "Running \"$(get_cmd enable)\""
$(get_cmd enable)
[[ $? -ne 0 ]] && fail "Unable to enable ipsec service"

cat << EOF

SUCCESS
Successfully configured and enabled the IPsec service.

The IPsec service has not been ${START}ed on this node.
Once each node in the PCE cluster has the IPsec service configured and enabled,
please either reboot all PCE nodes or run "$(get_cmd ${START})" on all nodes.
To check if ipsec is running, please run the command "$(get_cmd status)".

To disable the ipsec service, run this script with the "-disable" argument.

EOF
exit 0
END_OF_TEMPLATE
IFS=$OLDIFS
chmod +x "${OUTPUT}"

cat <<EOF

SUCCESS
Wrote script to file "$OUTPUT".

Please run script as root on each node of the PCE cluster to enable IPsec.

EOF
